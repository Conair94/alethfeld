import Mathlib.GroupTheory.Index
import Mathlib.GroupTheory.Subgroup.Basic
import Mathlib.GroupTheory.QuotientGroup
import Mathlib.GroupTheory.Isomorphism

namespace AlethfeldLean.Examples.PrimeIndexSubgroup

open Subgroup

/--
Alethfeld Theorem: prime-index-subgroup
Original statement: Let $G$ be a group. Let $H \unlhd G$ with $[G:H] = p$, where $p$ is prime. Let $K \leq G$. Then $K \leq H \lor (G = HK \land [K : K \cap H] = p)$.
-/
theorem prime_index_subgroup
  {G : Type*} [Group G]
  {H : Subgroup G} [hH : H.Normal]
  {K : Subgroup G}
  {p : ℕ} [hp : Fact p.Prime]
  (h_index : H.index = p) :
  K ≤ H ∨ (H ⊔ K = ⊤ ∧ (H ⊓ K).relindex K = p) := by

  -- Node: :hk-subgroup
  -- Statement: Since H ⊴ G, the set product HK is a subgroup of G such that H ≤ HK ≤ G.
  -- Justification: :external-application
  -- In Mathlib, H ⊔ K is the subgroup generated by union. Since H is normal, H ⊔ K = HK.
  have h_hk_subgroup : H ⊔ K = H * K := by
    rw [Subgroup.mul_normal H K]

  -- Node: :index-formula
  -- Statement: [G:H] = [G:HK][HK:H]
  -- Justification: :external-application
  -- Mathlib: index_eq_mul_of_le
  have h_index_mul : H.index = (H ⊔ K).index * (H.subgroupOf (H ⊔ K)).index := by
    rw [← index_mul_index (le_sup_left : H ≤ H ⊔ K)]

  -- Node: :index-values
  -- Statement: Since [G:H] = p is prime, and [G:HK] divides [G:H], implies [G:HK] ∈ {1, p}.
  -- Justification: :algebraic-rewrite
  have h_index_hk_values : (H ⊔ K).index = 1 ∨ (H ⊔ K).index = p := by
    rw [h_index] at h_index_mul
    have h_div : (H ⊔ K).index ∣ p := by
      use (H.subgroupOf (H ⊔ K)).index
      rw [mul_comm]
      exact h_index_mul
    exact (Nat.Prime.dvd_iff_eq (Fact.out p.Prime) (ne_of_gt (index_pos (H ⊔ K)))).mp h_div

  -- Case split based on index values
  cases h_index_hk_values with h_hk_index_1 h_hk_index_p

  -- Case 2: [G:HK] = 1
  -- Node: :case-2-impl
  -- Statement: If [G:HK] = 1, then G = HK. By Second Iso Thm, [K : K ∩ H] = p.
  { right
    constructor
    -- G = HK
    { exact index_eq_one.mp h_hk_index_1 }
    -- [K : K ∩ H] = p
    {
      -- [HK : H] = [G : H] / [G : HK] = p / 1 = p
      have h_hk_h_index : (H.subgroupOf (H ⊔ K)).index = p := by
        rw [h_index, h_hk_index_1, one_mul] at h_index_mul
        exact h_index_mul
      -- Second Isomorphism Theorem for indices: [HK : H] = [K : K ∩ H]
      -- Mathlib: index_sup_right_eq_relindex
      rw [← index_sup_right_eq_relindex]
      exact h_hk_h_index
    }
  }

  -- Case 1: [G:HK] = p
  -- Node: :case-1-impl
  -- Statement: If [G:HK] = p, then [HK:H] = 1, so HK = H, so K ≤ H.
  { left
    have h_hk_h_index_1 : (H.subgroupOf (H ⊔ K)).index = 1 := by
      rw [h_index, h_hk_index_p] at h_index_mul
      -- p = p * x => x = 1 (since p > 0)
      nth_rw 1 [← mul_one p] at h_index_mul
      exact mul_left_cancel₀ (ne_of_gt (Nat.Prime.pos (Fact.out p.Prime))) h_index_mul

    -- [HK : H] = 1 => HK = H
    have h_hk_eq_h : H.subgroupOf (H ⊔ K) = ⊤ := by
      exact index_eq_one.mp h_hk_h_index_1

    -- This implies H ⊔ K = H (as subgroups of G)
    -- H ≤ H ⊔ K is always true. If index of H in H ⊔ K is 1, then H = H ⊔ K.
    have h_sup_eq_h : H ⊔ K = H := by
       -- This requires unwrapping the subtype equality or using logical steps
       -- Simplified: H is a subgroup of H ⊔ K. If index is 1, they are equal.
       have := index_eq_one.mp h_hk_h_index_1
       -- Mapping back to G?
       -- Effectively K ≤ H ⊔ K = H
       sorry -- Tactic state manipulation needed here to pull back to G

    rw [sup_eq_left] at h_sup_eq_h
    exact h_sup_eq_h
  }
